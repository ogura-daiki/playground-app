<!DOCTYPE html>
<html>

<head>
  <meta charset="UTF-8" />

  <style>
    * {
      box-sizing: border-box;
    }

    html,
    body,
    playground-app {
      width: 100%;
      height: 100%;
      margin: 0px;
      padding: 0px;
    }
  </style>
</head>

<body>

  <script>

    //ほぼほぼ重複しないIDを生成
    const createProjectId = ()=>`${Date.now()}-${crypto.randomUUID()}`;
    window.createProjectId = createProjectId;
    const initialProjectId = createProjectId();

    const migrationsMap = {
      "config": [
        {
          v: 0,
          up: () => {
            return {
              layout:1,
              refresh_wait:1000,
              auto_refresh:false,
            };
          }
        },
      ],
      "ctx": [
        {
          v: 0,
          up: () =>{
            return {
              value:"",
            }
          }
        },
        {
          v: 1,
          up: () => {
            return {
              project:initialProjectId,
              opened:0,
            }
          }
        }
      ],
      "projects": [
        {
          v: 0,
          up: () => {
            return [
              {
                id:initialProjectId,
                name:"新規プロジェクト",
                files:[
                  {
                    id:0,
                    path:"index.html",
                    value:"",
                  }
                ],
              }
            ];
          }
        }
      ]
    };

    const store = {
      get(key){
        return JSON.parse(localStorage.getItem(key));
      },
      set(key, value){
        return localStorage.setItem(key, JSON.stringify(value));
      },
    };

    const getValue = key => {
      const migrations = migrationsMap[key];
      //現在のバージョンを取得
      const version = store.get("version-" + key);
      //実施する必要のあるmigrationを取得
      let current = -1;
      if (typeof version === "number") {
        current = migrations.findIndex(m => m.v === version);
        if (current === -1) throw new Error(`migration missing. current:${version}`);
      }
      const migrationList = migrations.slice(current + 1);

      //保存されている内容を取得
      let obj = store.get("store-" + key);

      //実施すべきmigrationが無い場合は最新の状態になっているのでそのまま返す。
      if (migrationList.length === 0) return obj;

      //migrationを実施
      const migrated = migrationList.reduce((obj, m) => m.up(obj), obj);

      //一番最後のmigrationのバージョンを保存
      const lastMigration = migrationList.pop();
      store.set("version-" + key, lastMigration.v);
      setValue(key, migrated);
      return migrated;
    }

    const setValue = (key, obj) => {
      store.set("store-" + key, obj);
    }

    window.Store = Object.freeze(Object.assign(Object.create(null), {
      get:getValue, set:setValue,
    }));

  </script>

  <script type="module">
    import { LitElement, html, css } from 'https://unpkg.com/lit-element/lit-element.js?module';

    const debounce = func=>{
      let timer;
      return {
        clear: () => {
          clearTimeout(timer);
        },
        push(time, props) {
          this.clear();
          timer = setTimeout(()=>func(false, props), time);
        },
        force(props) {
          this.clear();
          func(true, props);
        },
      };
    }

    class PlayGroundApp extends LitElement {
      static get properties(){
        return {
          config:{type:Object},
          ctx:{type:Object},
          projects:{type:Array},
          menu_opened:{type:Boolean},
        };
      }
      constructor(){
        super();
        this.updater = debounce((force, {value, auto_refresh}) => {
          if(force || auto_refresh){
            this.renderRoot.querySelector("#demo-view").content = value;
          }
        });
        this.config = Store.get("config");
        this.ctx = Store.get("ctx");
        this.projects = Store.get("projects");
        this.menu_opened = false;

        window.addEventListener("message", (event) => {
          this.renderRoot.getElementById("demo-view").sendMessage({
            type:"styles",
            value:{
              "test.css":`body{background:green}`,
            }
          });
        }, false);
      }
      static get styles(){
        return css`
          :host{
            display:block;
          }
          #container {
            background: #fff;
            gap: 4px;
          }

          #input {
            background: #000;
            color: #aaa;
            overflow: scroll;
            resize: none;
          }

          #ig {
            background: #eee;
          }

          .fill {
            width: 100%;
            height: 100%;
          }

          .col, .row{
            display:flex;
          }
          .col{
            flex-flow:column;
          }
          .row{
            flex-flow:row;
          }

          .grow{
            flex-grow:1;
            flex-basis:0px;
          }

          .top_menu{
            display:block;
            padding:4px 12px;
            width:52px;
            background:transparent;
            border-right:1px solid lightgray;
          }
          .menu_icon{
            position:relative;
            aspect-ratio:1;
            display:grid;
            place-items:center;
            width:100%;
            --stroke-color:white;
            --stroke-width:3px;
            transition:transform .3s;
          }
          .menu_icon:before, .menu_icon:after{
            content:"";
            display:block;
            width:100%;
          }
          .menu_icon:before{
            border:solid var(--stroke-color);
            border-width:var(--stroke-width) 0px;
            box-sizing:border-box;
            height:60%;
            transition:height .3s, background .3s, transform .3s, border .3s;
          }
          .menu_icon:after{
            height:var(--stroke-width);
            background:var(--stroke-color);
            position:absolute;
            top:calc(50% - var(--stroke-width) / 2 );
            left:0%;
            transition:transform .3s;
          }

          .open .menu_icon{
            transform:rotateZ(180deg);
          }
          .open .menu_icon:before{
            height:var(--stroke-width);
            background:white;
            border-width:0px;
            border-color:transparent;
            transform:rotateZ(45deg);
          }
          .open .menu_icon:after{
            transform:rotateZ(-45deg);
          }

          .projects_area{
            position:absolute;
            top:0px;
            left:0px;
            overflow-y:scroll;
            z-index:99999;
            background:white;
          }
          .projects_area .title{
            position:sticky;
            top:0px;
            background:white;
            padding:4px;
            font-size:1.5em;
          }
          .projects_area .projects{
            gap:8px;
            padding:8px;
          }
          
        `;
      }
      projectList(){
        return html`
          <div class="fill col projects_area">
            <div class="title">プロジェクト一覧</div>
            <div class="grow col projects">
              ${this.projects.map(({name})=>html`
                <div style="padding:4px;background:lightgray;">${name}</div>
              `)}
            </div>
          </div>
        `
      }

      getCurrentProject(){
        return this.projects.find(({id})=>id===this.ctx.project);
      }
      getCurrentFile(){
        return this.getCurrentProject().files[this.ctx.opened];
      }

      render(){
        return html`
          <div class="col fill">
            <div class="top_bar row" style="background:darkblue;">
              <button class="top_menu ${this.menu_opened?"open":""}" @click=${e=>this.menu_opened = !this.menu_opened}>
                <div class="menu_icon"></div>
              </button>
              <input type="text" .value=${this.getCurrentProject().name} @input=${e=>this.updateProjects(()=>{
                this.getCurrentProject().name = e.target.value;
              })}>
            </div>
            <div class="grow" style="position:relative;">
              <split-panel id="container" class="fill" count=2 weight_sum=2 weights="[1,1]" min_weights="[0.1,0.1]">
                <div slot=0 class="fill col">
                  <textarea id="input" class="grow" @input=${e=>{
                    this.updateProjects(ps=>{
                      this.getCurrentFile().value = e.target.value;
                    });
                    this.updater.push(this.config.refresh_wait, {
                      value:e.target.value,
                      auto_refresh:this.config.auto_refresh
                    });
                  }}>${this.getCurrentFile().value}</textarea>
                  <div>
                    <label>自動反映<input type="checkbox" .checked=${this.config.auto_refresh} @input=${e=>{
                      this.updateConfig(config=>{
                        config.auto_refresh = e.target.checked
                      });
                    }}></label>
                    <button id="run" @click=${e=>{
                      this.updater.force({value:this.getCurrentFile().value});
                    }}>RUN</button>
                  </div>
                </div>
                <div slot=1 class="fill">
                  <demo-view id="demo-view" class="fill" slot=1 .content=${this.getCurrentFile().value}></demo-view>
                </div>
              </split-panel>
              ${(this.menu_opened?()=>this.projectList():()=>"")()}
            </div>
          </div>
        `;
      }

      updateCtx(func){
        func(this.ctx);
        Store.set("ctx", this.ctx);
      }

      updateConfig(func){
        func(this.config);
        Store.set("config", this.config);
      }

      updateProjects(func){
        func(this.projects);
        Store.set("projects", this.projects);
      }
    }
    customElements.define("playground-app", PlayGroundApp);
    document.body.append(new PlayGroundApp());

    const styleLoader = async ()=>{
      const styles = await new Promise(resolve=>{
        window.addEventListener("message", ({data}) => {
          if(data.type = "styles"){
            resolve(data.value);
          }
        }, false);
        parent.postMessage("test", "*");
      });
      class StyleLoader extends HTMLElement {
        constructor(){
          super();
          const styleName = this.getAttribute("href");
          const styleSrc = styles[styleName] ?? "";
          this.before(Object.assign(document.createElement("style"), {innerHTML: styleSrc}));
          this.remove();
        }
      }
      customElements.define("style-loader", StyleLoader);
    }

    const func2ScriptElem = (func, type) => {
      const str = func+"";
      const funcContentStr = str.replace(/^[^{]*{/,"").replace(/}[^}]*$/,"");
      //インラインのスクリプトタグで定義しているので、直接閉じタグを使用するとHTMLの解析エラーになる
      return `<script type="${type}">${funcContentStr}${"</"}script>`;
    }

    const generateDemoPage = (input) => {
      const dom = new DOMParser().parseFromString(input, "text/html");
      dom.head.innerHTML = func2ScriptElem(styleLoader, "module") + dom.head.innerHTML;
      return dom.documentElement.innerHTML;
    }

    class DemoView extends HTMLElement {
      constructor(){
        super();
        this.attachShadow({mode:"open"});
        this.shadowRoot.innerHTML = `
        <style>${this.constructor.style}</style>
        <iframe id="iframe" sandbox="allow-scripts allow-modals allow-downloads">
        `;
      }
      set content(val){
        this.shadowRoot.querySelector("#iframe").srcdoc = generateDemoPage(val);
      }
      sendMessage(msg){
        this.shadowRoot.querySelector("#iframe").contentWindow.postMessage(msg, "*");
      }
      static get style(){
        return `
          :host{
            display:block;
          }
          html,body{
            width:100%;
            height:100%;
          }
          iframe{
            display:block;
            outline:none;
            border:none;
            width:100%;
            height:100%;
          }
        `;
      }
    }
    customElements.define("demo-view", DemoView);
    

    class Split extends LitElement {
      static get properties() {
        return {
          vertical: { type: Boolean },
          count: { type: Number },
          weight_sum: { type: Number },
          weights: { type: Array },
          min_weights: { type: Array },
          knob_overflow: { type: Boolean },
          md: { state: true },
        };
      }
      updateCurrentWeight(val) {
        this.currentWeight = this.weights.map(v => v / this.weight_sum);
      }
      constructor() {
        super();
        this.vertical = false;
        this.count = 5;
        this.weight_sum = 1;
        this.weights = [0.1, 0.2, 0.2, 0.2, 0.3];
        this.min_weights = [0.05, 0.05, 0.05, 0.05, 0.05];
        this.currentWeight = [];
        this.knob_overflow = false;
      }
      connectedCallback() {
        super.connectedCallback();
        window.addEventListener("mousemove", e => {
          if (this.md !== null) {
            let move = e.movementX / this.offsetWidth;
            if (this.vertical) {
              move = e.movementY / this.offsetHeight;
            }
            if (move < 0) {
              if (this.currentWeight[this.md] + move < this.min_weights[this.md]) {
                move = (this.min_weights[this.md] - this.currentWeight[this.md]) / this.weight_sum;
              }
              this.currentWeight[this.md] += move;
              this.currentWeight[this.md + 1] -= move;
            }
            else {
              if (this.currentWeight[this.md + 1] - move < this.min_weights[this.md + 1]) {
                move = (this.currentWeight[this.md + 1] - this.min_weights[this.md + 1]) / this.weight_sum;
              }
              this.currentWeight[this.md] += move;
              this.currentWeight[this.md + 1] -= move;
            }
            this.requestUpdate();
          }
        });
        window.addEventListener("mouseup", e => {
          this.md = null;
        });
      }
      createKnob(i) {
        const knob = html`
          <div class="knob ${this.vertical ? "v" : "h"}"
          @mousedown=${e => {
            this.md = i;
          }}></div>
        `;
        if (this.knob_overflow) {
          return html`
            <div style="
              overflow:visible;
              ${this.vertical ? "height" : "width"}:0px;
              position:relative;
              user-select:none;
            ">
              <div class="knob ${this.vertical ? "v" : "h"}" style="
                ${this.vertical ? "top" : "left"}:-4px;
                position:absolute;
              "
              @mousedown=${e => {
              this.md = i;
              console.log(i);
            }}></div>
            </div>
          `;
        }
        else {
          return knob;
        }
      }
      render() {
        if (this.currentWeight.length !== this.count) {
          this.updateCurrentWeight(this.count);
        }
        return html`
        <style>
          :host{
            cursor:${this.vertical ? "row-resize" : "col-resize"};
          }
        </style>
        <div style="width:100%;height:100%;display:flex;align-items:stretch;flex-direction:${this.vertical ? "column" : "row"};">
        ${[...Array(this.count)].map((v, i) => html`
          <slot
            name="${i}"
            style="
              ${this.md !== null ? "user-select:none;pointer-events:none;" : ""}
              ${this.vertical ? "height" : "width"}:${this.currentWeight[i] * 100}%;
              display:block;
              overflow:hidden;
            "
          >${i}</slot>
        `).reduce((c, v, i) => {
          c.push(v);
          if (i + 1 < this.count) {
            c.push(this.createKnob(i));
          }
          return c;
        }, [])}
        </div>
    `;
      }
      static get styles() {
        return css`
          :host{
            display:block;
          }
          .knob.h{
            background:rgba(99,99,99,.2);
            width:8px;
            height:max(100%,8px);
            border:solid rgba(50,50,50,.2) 1px;
            user-select:none;
            box-sizing:border-box;
            cursor:col-resize;
          }
          .knob.v{
            background:rgba(99,99,99,.2);
            height:8px;
            width:max(100%,8px);
            border:solid rgba(50,50,50,.2) 1px;
            user-select:none;
            box-sizing:border-box;
            cursor:row-resize;
          }
        `;
      }
    }

    customElements.define("split-panel", Split);
  </script>


</body>

</html>